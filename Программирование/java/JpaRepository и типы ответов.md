## Таблица с различными методами и их поведением в зависимости от наличия или отсутствия данных в базе данных:

| Метод                  | Возвращает при наличии данных в БД            | Возвращает при отсутствии данных в БД       |
|------------------------|------------------------------------------------|---------------------------------------------|
| `Optional<Collection<Entity>>` | `Optional.of(collection)` (непустая коллекция) | `Optional.empty()`                        |
| `Collection<Entity>`   | `collection` (непустая коллекция)              | `empty collection`                          |
| `Stream<Entity>`       | `stream` (непустой стрим)                      | `empty stream`                              |
| `Optional<Entity>`     | `Optional.of(entity)`                          | `Optional.empty()`                        |
| `Entity`               | `entity`                                       | `EntityNotFoundException` или `null` (зависит от настроек репозитория) |

### Дополнительные комментарии:
- **`Optional<Collection<Entity>>`**: Если в базе данных есть записи, метод вернет `Optional` с непустой коллекцией. Если записей нет, вернется `Optional.empty()`.
- **`Collection<Entity>`**: Всегда возвращает коллекцию, которая может быть пустой, если в базе данных нет записей.
- **`Stream<Entity>`**: Всегда возвращает стрим, который может быть пустым, если в базе данных нет записей.
- **`Optional<Entity>`**: Если запись найдена, метод вернет `Optional` с этой записью. Если запись не найдена, вернется `Optional.empty()`.
- **`Entity`**: Если запись найдена, метод вернет эту запись. Если запись не найдена, метод может выбросить исключение `EntityNotFoundException` или вернуть `null`, в зависимости от настроек вашего репозитория и конфигурации.


## Есть ли смысл переписывать все Collection\<T\> на Stream\<T\>?

Нет, не стоит переписывать все методы, возвращающие `Collection<T>`, на `Stream<T>`. Это может привести к ненужным усложнениям, изменению семантики использования и потенциальным рискам. Давайте разберём подробно, почему, а также затронем вашу мысль о `@Transactional`.

#### Различия между Collection и Stream
- **`Collection<T>`**:
  - Загружает все данные в память сразу (энергичная загрузка).
  - Прост в использовании: можно сразу итерировать, фильтровать вне запроса.
  - Не требует обязательных аннотаций, так как ресурсы (например, соединение с БД) освобождаются сразу после выполнения метода.
  - Подходит, когда данные невелики и нужны "здесь и сейчас" (например, для отображения в UI или простой обработки).

- **`Stream<T>`**:
  - Поддерживает ленивую загрузку (данные обрабатываются по мере необходимости, не всё сразу в память).
  - Экономит память и ресурсы для больших наборов данных (например, миллионы записей).
  - **Требует `@Transactional`** (как вы заметили, часто глобально-обязательно для Spring Data, но в контексте репозиториев — да, потому что поток открыт в рамках транзакции, и неправильное закрытие может привести к утечкам ресурсов, блокировкам БД или исключениям). Если transactional scope недостаточно широкий, данные могут быть недоступны, так как stream закрывается при выходе из транзакции.
  - Принуждает к обязательному закрытию (через `try-with-resources`), чтобы избежать утечек.
  - Подходит для потоковой обработки, агрегаций или когда не нужно держать всё в памяти.

**Когда переписывать?**
- Только если данные действительно большие и обработка требует ленивости (например, миллионы строк из БД). Иначе это оверхед без пользы.
- Примеры сценариев: экспорт данных, фильтрация на клиенте без загрузки всего набора.

#### Критерии и рекомендации использования методов
На основе таблицы, которую вы предоставили (и стандартных практик Spring Data JPA), вот рекомендации. Выбор зависит от семантики вашего API, ожиданий пользователя и требований к обработке отсутствия данных.

| Метод | Когда использовать | Преимущества | Недостатки | Рекомендации |
|-------|---------------------|--------------|------------|--------------|
| `Optional<Collection<Entity>>` | Когда важно явно сигнализировать о наличии/отсутствии коллекции, и пустая коллекция — это значимое отсутствие (например, для условной логики в коде). | Избегает null-проверок; семантически ясно (Optional пустой = никаких данных). | Нет специфики для размера данных; может быть избыточным, если коллекция всегда должна быть доступна. | Используйте только если логика зависит от "наличия коллекции как объекта". Предпочтите `Collection<Entity>`, если пустая коллекция — нормальный случай. |
| `Collection<Entity>` | Когда данные всегда ожидается коллекция (даже пустая), и нет нужды в специальной обработке отсутствия. Идеально для небольших наборов, где загрузка в память — норма. | Всегда возвращает валидный объект; просто в использовании (не требует try-catch или optional-проверок). Подходит для CRUD без транзакций. | Неструктурированное поведение при отсутствии данных; если набор большой, может вызывать OOM (out of memory). | Основной выбор для простых запросов. Если данные потенциально большие — рассмотрите `Stream<Entity>`. |
| `Stream<Entity>` | Для больших наборов данных, требующих потоковой обработки (фильтр, мап, агрегация) без загрузки всего в память. Или для ленивых операций. | Эффективен для big data; ленивый, сохраняет ресурсы. | Требует `@Transactional` и правильного закрытия (через `try( ... )`); не подходит для простого доступа (придётся конвертировать в список). Утечки ресурсов при неправильном использовании. Риск блокировок БД. | Используйте для батчей, экспорта, аналитики. Обязательно `@Transactional`. Избегайте, если пользователь просто хочет список. |
| `Optional<Entity>` | Для запросов, где ожидается 0 или 1 результат (например, findById). | Избегает null; семантически ясно (нет сущности = Optional.empty()). | Если сущность гарантированно существует, избыточно. | Лучший выбор для поиска одиночной сущности. Улучшает безопасность кода вместо null. |
| `Entity` | Когда сущность **обязательно должна существовать**, и отсутствие — это исключение (ошибка). | Прямолинейно; не требует обёрток. | Риск исключения или null (зависит от репозитория). | Используйте осторожно, только если отсутствие данных — баг. Предпочтите `Optional<Entity>` для большей безопасности. Если репозиторий возвращает null вместо исключения — проверяйте на null вручную. |

**Дополнительные общие рекомендации:**
- **Размер данных**: Для маленьких наборов (< сотен элементов) — `Collection` или `Entity`. Для больших — `Stream`, но с транзакциями и правильным управлением ресурсами.
- **Аннотация `@Transactional`**: 
  - Для `Stream` — почти всегда обязательна, чтобы поток работал правильно (данные остаются доступными в рамках транзакции).
  - Для `Collection` или других — зависит от операции (например, если модифицируете данные, аннопатуйте всегда).
- **Обработка ошибок**: `Entity` рискует выбросить `EntityNotFoundException` — используйте для строгих случаев. `Optional` и `Collection`/`Stream` позволяют гибкую обработку.
- **Производительность и память**: Измерьте — если с `Collection` всё ОК, не трогайте. `Stream` требует больше дисциплины.
- **API дизайн**: Делайте источником ваших репозиториев — клиента. Если Strawberry вызовет `Collection`, пусть сам решает, конвертировать в `Stream` или нет.
- **Тестирование**: Всегда тестируйте границы (пустые коллекции, потоки, отсутствующие сущности).

## Где это можно посмотреть? EntityNotFoundException или null (зависит от настроек репозитория)

Хороший вопрос! Поведение методов репозитория, таких как `findById`, `findOneById`, `getById`, и других, может зависеть от настроек вашего приложения и используемых аннотаций. Вот более подробная информация о том, где и как это можно настроить:

### 1. **Использование аннотации `@RepositoryRestResource`**

Если вы используете Spring Data REST, аннотация `@RepositoryRestResource` может влиять на поведение методов репозитория. Например:

```java
@RepositoryRestResource
public interface MyEntityRepository extends JpaRepository<MyEntity, Long> {
    // Методы репозитория
}
```

По умолчанию, методы типа `findById` будут возвращать `Optional<Entity>`. Однако, если вы хотите, чтобы методы возвращали `null` вместо `Optional.empty()`, вы можете изменить это поведение через настройки.

### 2. **Настройка поведения методов репозитория**

#### Использование `Optional<Entity>`

Методы, которые возвращают `Optional<Entity>`, такие как `findById`, будут автоматически обрабатывать случай отсутствия записи, возвращая `Optional.empty()`:

```java
public interface MyEntityRepository extends JpaRepository<MyEntity, Long> {
    Optional<MyEntity> findById(Long id);
}
```

#### Возврат `null`

Если вы хотите, чтобы методы возвращали `null` вместо `Optional.empty()`, вы можете использовать методы без `Optional`, такие как `findOneById` или `getById`:

```java
public interface MyEntityRepository extends JpaRepository<MyEntity, Long> {
    MyEntity findOneById(Long id); // Возвращает null, если запись не найдена
    MyEntity getById(Long id);      // Может выбросить EntityNotFoundException, если запись не найдена
}
```

### 3. **Исключения `EntityNotFoundException`**

Метод `getById` может выбросить исключение `EntityNotFoundException`, если запись не найдена. Это зависит от настроек вашего приложения и используемых библиотек. Например, если вы используете Spring Data JPA с Hibernate, `getById` может выбросить `javax.persistence.EntityNotFoundException`.

#### Пример:

```java
public interface MyEntityRepository extends JpaRepository<MyEntity, Long> {
    MyEntity getById(Long id); // Может выбросить EntityNotFoundException
}
```

### 4. **Настройка глобального поведения**

Вы также можете настроить глобальное поведение репозитория через файл конфигурации `application.properties` или `application.yml`. Например, вы можете указать, что методы должны выбрасывать исключения при отсутствии записей:

```properties
spring.jpa.open-in-view=false
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Настройка поведения методов репозитория
spring.data.rest.default-page-size=20
spring.data.rest.max-page-size=100
```

Однако, для конкретного поведения методов `findById`, `findOneById`, `getById` и т.д., рекомендуется явно указывать тип возвращаемого значения в интерфейсе репозитория.

### Заключение

Поведение методов репозитория зависит от того, какой тип вы указываете в сигнатуре метода. Для более точного контроля над поведением рекомендуется использовать `Optional<Entity>` или явно указывать `null` возвращаемое значение. Исключения `EntityNotFoundException` могут быть выброшены при использовании методов типа `getById`, но это зависит от настроек вашего приложения и используемых библиотек.

Для получения более подробной информации можно обратиться к [официальной документации Spring Data JPA](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/) и [Spring Data REST](https://docs.spring.io/spring-data/rest/docs/current/reference/html/).