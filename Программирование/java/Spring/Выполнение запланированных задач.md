# Выполнение запланированных заданий в Spring Boot

## Введение
Запланированные задания (scheduled tasks) позволяют выполнять части логики приложения в определённое время или с фиксированными интервалами. Это полезно для задач вроде обновления данных, отправки уведомлений или очистки кэша. Spring Boot упрощает реализацию с помощью аннотации `@Scheduled`, которая является частью основного модуля Spring. В этой статье мы рассмотрим настройку, примеры кода и лучшие практики для планирования заданий в Spring Boot 3.5 с Java 21. Материал включает интеграцию с внешними инструментами для распределённых сред.

## Включение планирования
По умолчанию планирование отключено. Чтобы активировать его, добавьте аннотацию `@EnableScheduling` к основному классу приложения или конфигурационному классу.

```java
@SpringBootApplication
@EnableScheduling
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

Для лучшей модуляризации вынесите это в отдельный конфигурационный класс:

```java
@Configuration
@EnableScheduling
public class SchedulerConfig {
}
```

Spring сканирует бины на наличие методов с `@Scheduled` и планирует их выполнение.

### Условное включение через свойства
Чтобы отключать планирование во время тестов или в продакшене, используйте `@ConditionalOnProperty`:

```java
@Configuration
@EnableScheduling
@ConditionalOnProperty(name = "scheduler.enabled", matchIfMissing = true)
public class SchedulerConfig {
}
```

В `application.properties` укажите:
```
scheduler.enabled=true
```
По умолчанию планирование включено, если свойство не задано.

## Аннотация @Scheduled
Аннотация `@Scheduled` применяется к методам бинов Spring. Метод должен быть `void` и без параметров. Атрибуты для задания интервала:
- `fixedDelay` / `fixedDelayString`: задержка между завершением предыдущего и началом следующего выполнения.
- `fixedRate` / `fixedRateString`: фиксированный интервал между запусками (независимо от времени выполнения).
- `initialDelay` / `initialDelayString`: задержка перед первым запуском.
- `cron`: выражение в стиле cron для сложных расписаний.

### Выполнение с фиксированной задержкой
`fixedDelay` гарантирует последовательное выполнение: следующее задание ждёт завершения предыдущего.

```java
@Service
public class PricingEngine {
    private static final Logger LOGGER = Logger.getLogger(PricingEngine.class.getName());

    @Scheduled(fixedDelay = 2000) // 2 секунды после завершения
    public void computePrice() throws InterruptedException {
        LOGGER.info("Computing price at " + LocalDateTime.now().toEpochSecond(ZoneOffset.UTC));
        Thread.sleep(4000); // Симуляция долгой операции
    }
}
```

Здесь следующее выполнение начнётся через 4 секунды (время выполнения + задержка).

### Выполнение с фиксированной частотой
`fixedRate` запускает задания через фиксированный интервал, даже если предыдущее ещё выполняется. Для параллелизма добавьте `@Async`.

```java
@Configuration
@EnableScheduling
@EnableAsync
@ConditionalOnProperty(name = "scheduler.enabled", matchIfMissing = true)
public class SchedulerConfig {
}

@Service
public class PricingEngine {
    @Scheduled(fixedRate = 3000) // Каждые 3 секунды
    @Async
    public void refreshPricingParameters() {
        LOGGER.info("Refreshing parameters at " + LocalDateTime.now().toEpochSecond(ZoneOffset.UTC));
    }
}
```

Без `@Async` задания выполняются последовательно.

### Отсрочка первого выполнения
Добавьте `initialDelay` для задержки первого запуска.

```java
@Scheduled(initialDelay = 2000, fixedRate = 3000)
public void refreshPricingParameters() {
    // Первый запуск через 2 секунды после старта приложения
}
```

### Формат длительности ISO
Для читаемости используйте строки вроде "PT02S" (2 секунды) вместо миллисекунд.

```java
@Scheduled(fixedDelayString = "PT02S")
public void computePrice() {
    // Задержка 2 секунды
}
```

### Вынесение интервалов в свойства
Экстернализуйте интервалы в `application.properties`:

```
interval=PT02S
interval-in-cron=0 * * * * *
```

```java
@Scheduled(fixedDelayString = "${interval}")
public void computePrice() {
    // Использует значение из properties
}
```

### Выражения Cron
Для сложных расписаний используйте cron-выражения (6 полей: секунды, минуты, часы, день месяца, месяц, день недели).

```java
@Scheduled(cron = "${interval-in-cron}")
public void computePrice() {
    // Каждый час: 0 0 * * * *
}
```

Макросы для удобства:
- `@hourly` (0 0 * * * *)
- `@daily` (0 0 0 * * *)
- `@weekly` (0 0 0 * * 0)
- `@monthly` (0 0 0 1 * *)
- `@yearly` (0 0 0 1 1 *)

## Пример проекта
Рассмотрим полный пример с сервисом для обновления цен.

```java
// Сервис
@Service
public class PricingEngine {
    private Double price;

    @Scheduled(fixedDelayString = "${pricing.interval}")
    public void computePrice() throws InterruptedException {
        Random random = new Random();
        price = random.nextDouble() * 100;
        LOGGER.info("Price computed: " + price);
        Thread.sleep(2000);
    }

    public Double getPrice() {
        return price;
    }
}

// Контроллер для проверки
@RestController
public class PricingController {
    @Autowired
    private PricingEngine pricingEngine;

    @GetMapping("/price")
    public ResponseEntity<Double> getPrice() {
        return ResponseEntity.ok(pricingEngine.getPrice());
    }
}
```

В `application.properties`:
```
pricing.interval=PT05S
scheduler.enabled=true
```

## Лучшие практики
- **Выбор типа интервала**: `fixedDelay` для последовательных задач, `fixedRate` для независимых.
- **Асинхронность**: Для `fixedRate` добавляйте `@Async` для параллелизма.
- **Тестирование**: Отключайте планирование в тестах с `@TestPropertySource(properties = "scheduler.enabled=false")`.
- **Мониторинг**: Используйте Spring Boot Actuator для метрик потоков.

### Развертывание в распределённых средах с ShedLock
В кластере несколько инстансов могут запускать задания одновременно. ShedLock предотвращает это, используя блокировку в общей БД.

Добавьте зависимости:
```xml
<dependency>
    <groupId>net.javacrumbs.shedlock</groupId>
    <artifactId>shedlock-spring</artifactId>
    <version>4.27.0</version>
</dependency>
<dependency>
    <groupId>net.javacrumbs.shedlock</groupId>
    <artifactId>shedlock-provider-jdbc-template</artifactId>
    <version>4.27.0</version>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
```

Обновите конфигурацию:
```java
@Configuration
@EnableScheduling
@EnableSchedulerLock(defaultLockAtMostFor = "10m")
public class SchedulerConfig {
    @Bean
    public LockProvider lockProvider(DataSource dataSource) {
        return new JdbcTemplateLockProvider(
            JdbcTemplateLockProvider.Configuration.builder()
                .withJdbcTemplate(new JdbcTemplate(dataSource))
                .usingDbTime()
                .build()
        );
    }
}
```

Создайте таблицу:
```sql
CREATE TABLE shedlock(
    name VARCHAR(64) NOT NULL,
    lock_until TIMESTAMP(3) NOT NULL,
    locked_at TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
    locked_by VARCHAR(255) NOT NULL,
    PRIMARY KEY (name)
);
```

Аннотируйте метод:
```java
@Scheduled(cron = "0 * * * * *")
@SchedulerLock(name = "computePriceTask")
public void computePrice() {
    // Выполняется только на одном инстансе
}
```

### Альтернативы: Quartz Scheduler
Для сложных сценариев (кластеризация, персистентность) используйте Quartz. Он поддерживает JTA-транзакции и возобновление заданий после сбоев. Spring Scheduler проще для базовых задач, но Quartz лучше для продакшена с кластерами.

## Интеграция с Java 21 и Spring Boot 3.5
Spring Boot 3.5 поддерживает виртуальные потоки Java 21 для лёгких задач. Для `@Scheduled` с `@Async` настройте executor:

```java
@Bean
public Executor virtualThreadExecutor() {
    return Executors.newVirtualThreadPerTaskExecutor();
}

@EnableAsync(executor = "virtualThreadExecutor")
```

Это эффективно для I/O-bound задач в планировщике.

## Заключение
Spring Boot упрощает планирование заданий с `@Scheduled`. Начинайте с простых интервалов, переходите к cron для сложности. Для кластеров используйте ShedLock или Quartz. Следуйте примерам, тестируйте и мониторьте. Полный код на GitHub. Для вопросов — пишите!

Дополнительные статьи:
1. [Выполнение запланированных заданий в Spring Boot](https://habr.com/ru/articles/580062/)